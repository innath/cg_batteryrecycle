import { DestinationFetchOptions } from './destination-accessor-types';
import { Destination } from './destination-service-types';
/**
 * @internal
 */
export declare const registerDestinationCache: import("./destination-cache").DestinationCacheType;
/**
 * @experimental This API is experimental and might change in newer versions. Use with caution.
 *
 * Represents options to configure how a destination should be registered.
 */
export type RegisterDestinationOptions = Pick<DestinationFetchOptions, 'jwt' | 'isolationStrategy'> & {
    inferMtls?: boolean;
};
/**
 * Registers a destination in a cache for later usage.
 *
 * If a destination with the same key is already in the cache, it is replaced.
 * The key is built using the `getDestinationCacheKey` method.
 * @param destination - A destination to add to the `destinations` cache.
 * @param options - Options how to cache the destination.
 */
export declare function registerDestination(destination: DestinationWithName, options?: RegisterDestinationOptions): Promise<void>;
/**
 * Represents a destination with a `name` property.
 */
export type DestinationWithName = Destination & {
    name: string;
};
/**
 * @internal
 * @param options - The options for searching the cache
 * @returns Destination - the destination from cache
 */
export declare function searchRegisteredDestination(options: DestinationFetchOptions): Promise<Destination | null>;
/**
 * This method either decodes the given JWT. If the JWT is not given it will use the subdomain if the XSUAA and create a Object with zid this subdomain.
 * This is then passed on to build the cache key.
 * @param options - Options passed to register the destination containing the jwt.
 * @returns The decoded JWT or a dummy JWT containing the tenant identifier (zid).
 * @internal
 */
export declare function decodedJwtOrZid(options?: RegisterDestinationOptions): Record<string, any>;
